# 正则表达式匹配

维护一个dp数组，$dp[i][j]$表示字符串s前$i+1$位与表达式串p前$j+1$位是否匹配，有两种状态，True表示匹配，False表示不匹配。

初始情况：

1. p为空串，s不为空串，肯定不匹配，$dp[i][0]=False$。
2. s为空串，但p不为空串，要想匹配，只可能是右端是星号，干掉一个字符后p变为空串，$dp[0][c] = dp[0][c-2]$。如果右端不是星号，不匹配。
3. s、p都为空串，肯定匹配。

构建包含'\.'与'\*'的正则匹配，p串末位有三种情况，分为两条叙述：

1. $s[i] = p[j]$ 或$p[j] = '.'$，此时s串与p串最后一位都为表示字符。

2. $p[j]='*'$，此时p串末尾位'\*'，又可分为：

   1. $s[i]=p[j-1]$  '\*'前一位的字符与s串末位字符相同，或者'\*'前为'\.'，此情况下$p[j-1]与p[j]$两位能够$s[i]$匹配上。

      只需要看$s[i]$前面的子串能否与p串匹配，考虑一下两种情况，满足其一即匹配：

      1. $dp[i][j] = dp[i-1][j]$，此时'#\*'至少匹配了一位字符。

         > 例如匹配#bb与 ##b\*，b\*匹配了2个字符。

      2. $dp[i][j] = dp[i][j-2]$，此时'#\*'没有匹配到字符。

         > 例如匹配##b 与  ##bb*，b\*实际上没有匹配到字符。

   2. $s[i] != p[j-1]$ '\*'前一位的字符与s串末位字符不同，此时只需考虑$dp[i][j]=dp[i][j-2]$ 即'#\*'前的表达式是否与子串匹配。

3. 其他情况则表达式无法匹配。